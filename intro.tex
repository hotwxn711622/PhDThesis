An operating system (OS) kernel serves as the lowest level of any
system software stack. The correctness of the OS kernel is the basis
for that of the entire system.
Despite being highly desired verification target, recent work
has shown that the potential cost for verifying
reasonably practical operating system could be 
prohibitive~\cite{klein2009sel4,klein14}.

To make formal verification of any of similar complex system software
practical, we currently lack a unified language-based framework that allows us
to formally express, untangle, and reason about the interdependent relationships
among various components in complex system software like OS kernel.
Formal verification, by nature, involves in at least two types of languages.
Low level languages (like C or assembly) that are used to implement
the actual system software, and rich specification languages used to specify
various behaviors of the programs. The framework needs to support both
kinds of languages in a unified system, and provide formal way of effectively
reason about relationships between these two types of languages. In practice, many
formal verification is done on separate models that are not directly connected to the
actual running code. This would also mean that if the low level language contains
both C and assembly language, it should also provide certified compilation service
that can compile the corresponding C code and its specification down to equivalent
assembly version that can be formally linked together with the code that is written
and verified directly at the assembly level. 

Furthermore, complex system software contains many different abstraction
layers, where each layer implements its own functionality by calling into the
interfaces of other lower level  layers, and expose a new abstract
interface to outside. The clients of this library only ever look at the
interface and their specification (normally written in natural language),
and does not need to look into the actual internal implementation.
This way, we often can keep various changes only local to the component,
and replace one component easily with another one with similar interfaces.
Despite abstraction layers are highly exercised in building complex
system software, it has not been adapted into formal verification of proving
those system software. We lack a framework that can allow us to discompose
a complex system software into various small components across multiple
abstraction layers, prove each part of the code in their most appropriate abstraction
layers, formally compose the verified layers into bigger layer component with formal
public interface such that we never need to look into the internal implementation of the layer,
and makes it easy to replace one plugin with another component that has the same
interface and also satisfies the same linking invariants.

In this thesis, I present a novel compositional  framework that successfully
tackles all of the above challenges in a unified way. The framework,
which is implemented fully in Coq proof assistant, allows
you to build hierarchy of certified abstraction layers that can be horizontally
and vertically composed. It also provides a variant of C and assembly language
that can be used for system implementation, the rich Coq logical language
for specifying the behaviors of the programs, and a certified compiler that can compile
the C code and proofs into equivalent assembly versions that can be formally linked
with the ones obtained directly from assembly. It also contains powerful
Coq tactic library that can be used to automate many aspect of the proofs.
This framework is illustrated in
detail in Chapter \ref{chapter:framework} and Chapter \ref{chapter:automation}.
Under our framework, building a new certified kernel is the matter of
composing a collection of certified layers. The framework has been used to
construct a practical operating system kernel with rich features like virtual
memory, process management, hardware virtualization, {\it etc}, which is
presented in Chapter \ref{chapter:sequential}.

In a monolithic kernel, device drivers
form the majority of the code base; 70\% of the Linux 2.4.1 kernel are
device drivers~\cite{Chou:2001}. Furthermore, such drivers are found
to be the major source of crashes in the Linux and Windows operating
systems~\cite{Chou:2001,Ball:2006,Ganapathi:2006}. While recent
efforts on seL4~\cite{klein14} and CertiKOS~\cite{dscal15} have
demonstrated the feasibility of building formally verified OS kernels,
it is unclear how to extend their work to verify the functional
correctness of device drivers. In CertiKOS~\cite{dscal15}, drivers are
unverified, and it is not obvious how to extend their framework to
model devices and interrupts. In a microkernel like
seL4~\cite{klein14}, device drivers are implemented in user space,
and, though its proofs guarantee driver isolation, it does not
eliminate bugs in its user-level drivers.
% The Verisoft team~\cite{verisoft07} has done a large body of work
% aiming to verify an OS kernel with device drivers
% \cite{Alkassar:OSVE09,Alkassar:VSTTE08-225,Alkassar:VSTTE2010-71},
% but their drivers are verified completely at the assembly level.
% Furthermore, they put many restrictions on the devices they can
% verify, many of which are not satisfied by a large number of
% existing devices.

A major challenge in driver verification is the interrupt: a non-local
jump to some driver code, triggered by a device. When device drivers
are implemented inside the kernel (for better performance), the kernel
should be interruptible; otherwise, it can lead to an unacceptable
interrupt processing latency.  Reasoning about interruptible code is
particularly challenging, since every fine-grained processor step
could contain a non-local jump, and, upon return, the machine state
could be substantially changed. Even worse, it is not clear how such
reasoning should be done at the C level, which is completely
interrupt-unaware. Existing work either assumes that interrupts are
turned off inside the kernel~\cite{dscal15,verisoft07}, or polls the
interrupts at a few carefully chosen interrupt points~\cite{klein14}.

Furthermore, interrupt hardware is not static, but is configured by
software. In order to verify any interesting device drivers (serial,
disk, {\it etc}.), we first need to model the interrupt controller
devices (e.g., LAPIC~\cite{mps97}, I/O APIC~\cite{ioapicd96}), and
formally verify their drivers. This is important because, if the
interrupt controllers are not initialized properly, it may lead to
undesired interrupt behaviors. Device drivers also interact with
interrupt controllers to mask/unmask particular interrupt lines.
These issues have been overlooked in past work, where 
interrupt controllers are assumed to be properly initialized and
their drivers are correctly implemented~\cite{Alkassar:VSTTE08-225}.

Finally, verifying an interruptible operating system with device
drivers also faces the following challenges.

{\em Devices and CPU run in parallel.} Thus, the executions of CPU
instructions and device transitions can interleave arbitrarily. Code
verification on this highly nondeterministic machine can be
challenging, since it needs to consider device state transitions, even
when the CPU is executing a set of instructions unrelated to external
devices. Recent
work~\cite{Alkassar:OSVE09,Alkassar:VSTTE08-225,Alkassar:VSTTE2010-71}
tries to address this by enforcing a {\it stability} requirement
that device states only change due to CPU operations. 
%
% Using this assumption, they have proven a reordering
% theory and applied it to postpone the execution of all CPU instructions
% unrelated to the device that is currently being manipulated.  They are then
% able to turn the set of assembly level device operations into
% atomic primitives, which are then lifted to their C level verification
% framework as inline-assembly calls~\cite{Alkassar:VSTTE2010-71}.
% Though the stability assumption suffices for their use case, it is
%
This requirement is, however, 
too strong as devices interacting with 
external environments are not stable: a serial device constantly
receives characters through its port, a network card continuously
transfers packets, an interrupt controller (IC) asynchronously
receives interrupt requests, {\it etc}.

{\em Devices may directly interact with each other.} Existing work
assumes that a device driver monopolizes its underlying device and
devices do not influence each other~\cite{Alkassar:VSTTE08-225}. This
assumption does not hold for many devices in practice. For example,
most devices directly communicate with an interrupt controller by
signaling an interrupt.

{\em Device drivers are written in both assembly and C.}  Existing
device driver verification is either done completely at the assembly
level \cite{Alkassar:VSTTE08-225,duan2013} or the verified properties
are only guaranteed to hold at the C level \cite{Ryzhyk_09,Ryzhyk14}.
For realistic use-cases, proven properties should be 
translated down and then formally linked with
the assembly-level proofs.

% {\em The correctness of device drivers needs to be formally connected
%   to the correctness of the OS kernel in a single proof
%   context.}
%
{\em The correctness results of different components should be
integrated formally.} For example, the correctness proofs of device
drivers and the OS kernel
% , both written in a combination of C and assembly,
need to be formally linked as an integrated system,
before one can deliver formal guarantees on the OS as a whole. Not
doing so can introduce semantic gaps among different modules,
% wherein a module makes assumptions contradicting with those of another,
a scenario which introduced actual bugs in previous verification
efforts as reported by Yang and Hawblitzel~\cite{hawblitzel10}. Unfortunately,
this formal linking process was found to be even more challenging than
the correctness proofs of individual modules
themselves~\cite{Alkassar:VSTTE08-225}. Even OS's with user-level
device drivers can suffer if the correctness proofs of their drivers are not
formally linked with those of the kernel. For example,
if some device driver code triggers a page fault at the user level,
the behavior of the corresponding driver is linked to the behaviors of
the page-fault handlers and address translation mechanism of the kernel.

In this thesis, I also propose a novel compositional approach that tackles
all of the above challenges. There are two key contributing ideas.
One is to build up a certified ``virtual'' device hierarchy, and
the other is a new abstract interrupt model, built upon a realistic
hardware interrupt model through contextual refinement. We use these
to build an extensible framework that systematically enforces the
isolation among different operating system modules, which is important
for scalability of any verification effort and critical for reasoning
about interruptible code. The details are presented in Chapter \ref{chapter:driver}.

Last not the least, majority of recent OS kernels are running on multiple CPUs and supports
multiple threads.   Recent
efforts~\cite{klein2009sel4,hawblitzel10,klein14,ironclad14,fscq15,cogent16}
have shown that it is feasible to formally prove the functional
correctness of simple general-purpose kernels, file systems,
and device drivers. However, none of these systems have addressed the
important issues of concurrency~\cite{kaashoek15,ospp11}
Through our work on device drivers and interrupts, even though
we are able to reason about some limited form of concurrency between the kernel and
devices, efficient reasoning on arbitrary concurrent executions among various
interdependent components in a complex system like OS kernel is considered
intractable by some researchers~\cite{vontessin13,peters15}. 
In order to reason about concurrent programs effectively, we first need to write
effective specifications. For example, for an operation to a concurrent object whose
access is protected by a lock, even though there can be many interleaved executions
in the middle of the operation, the operation is considered ``atomic'', and this
information should be reflected in a good abstract specification, i.e.,
the specification should also be atomic. The reasoning framework should also support
local reasoning of concurrent programs, e.g., we should be able to reason about
each thread locally by making appropriate assumptions on its partnering threads,
and later merge all the proofs together to obtain a properly about the entire
concurrent program when they all gets executed together. To do this, it is important
that the framework is able to prove that each of the system calls eventually returns,
which is dependent both on the progress and behavior of current and other programs
running on the machine.

We have further extended our layered framework to support the certified
concurrent abstraction layers. We have a very effective way of representing
states shared among processes running on other CPUs, and enforcing invariants on
the current process, and assumptions on the other processes. This way, it allows
us to formally verify the code running on each processes separately, and later
link the code and proofs together when they satisfy each other assumptions,
to obtain global properties on entire system when the processes are run in parallel.
Using this framework,
we have successfully verified common spinlock implementations with effective
atomic specifications for their lock acquire and release operations, and further utilize
the verified locks to implement other concurrent components of the kernel.
This line of work is detailed in Chapter \ref{chapter:concurrent}.

This dissertation makes the following new contributions:
\begin{itemize}
\item We present the first language-based framework for systematically
building hierarchy of certified abstraction layers used widely in the system
community. Each certified layer interface not only specifies precise functionality
of underlying implementation, but also clear assumptions about its client context.
The framework allows us to effectively decompose otherwise complex
artifacts into many different abstraction layers, and provides system level support
for formally specifying, programming, and verifying the layer components,
and more importantly, compose the components into a bigger abstraction layers.

\item In the framework, we provide both a variant of C language (ClightX),
and an x86 assembly language, and a modified version of CompCert verified
compiler that can compile the code and proofs regarding ClightX into
the equivalent ones in assembly. We have implemented (in Coq) strong
automation tactics that can be used to semi-automatically prove the
ClightX code against their specifications, and tactics for proving refinement
properties across various proof patterns.

\item Using these new tools, we have successfully constructed a
practical feature-rich certified OS kernels with virtual memory,
thread/process management, hardware assisted virtualization,
and trap handlers. It can run on stock x86 multicore machines
and also could double as a hypervisor and boot a version of Linux as guest.
The certified kernel is built through 35 logical
abstraction layers, and turn
an otherwise prohibitive verification task into many simple
and easily automatable sub-tasks.
The certified
kernel provides the actual assembly implementation running on the
actual hardware, abstract high level specifications of the kernel,
and machine checkable proof stating that for every kernel or user
program $P$, any properly of $P$ over the kernel specification
is preserved when running the $P$ linked with the kernel assembly
implementation.  The entire specification and verification
effort took less than 2 person years.

\item We have extended the framework further into a new extensible
architecture for building certified
  OS kernels with device drivers. Instead of mixing the device drivers
  with the rest of the kernel (since they both run on the same
  physical CPU), we treat the device drivers for each device as if
  they were running on a ``logical'' CPU dedicated to that device.
  This novel idea allows us to build up a certified hierarchy of
  extended abstract devices over the raw hardware devices, meanwhile,
  systematically enforcing the isolation among different ``devices''
  and the rest of the kernel.

%%%%%
\item We present a novel abstraction-layer-based approach for
  expressing interrupts, which enables us to build certified
  {\em interruptible} OS kernels and device drivers. Our formalization of
  interrupts includes a realistic hardware interrupt model, and an
  abstract model of interrupts which is suitable for reasoning about
  interruptible code. We prove that the two interrupt models are
  contextually equivalent.

%%%%%
\item We present, to the best of our knowledge, the first verified
  interruptible OS kernel and device drivers that come with
  machine-checkable proofs.  The implementation, modeling, specification, and
  proofs are all done in a unified framework (realized in the Coq
  proof assistant~\cite{coq}), yet the machine-checkable proofs verify the
  correctness of the assembly code that can run on the actual
  hardware.
  
\item We have developed an effective event-based framework for representing
shared states, and further extended existing framework into an architecture
for building certified concurrent OS kernels. The framework utilizes contextual
refinement over the concurrent environmental contexts as the unifying formalism
for component various concurrent objects at different abstraction levels. 
The environmental context allows us to make proper assumptions over
other concurrent processes, and enables us to be able to reuse majority
of standard verification techniques we have developed for verifying sequential programs.

\item Using the new framework, we have successfully developed fully certified
concurrent OS kernel with fine grained locking. The concurrent kernel
consists of 6,500 lines of C and assembly code, runs on stock x86 multicore machines,
and doubles as a hypervisor and boot multiple instances of Linux as guest on different
CPUs. To the best of our knowledge, this is the first fully verified general-purpose concurrent
OS kernel with fine-grained locking.
\end{itemize}

%The rest of this thesis is organized as follows.
%Chapter~\ref{chapter:framework} presents our abstraction-layer-based verification
%technology using a concrete example, while
%Chapter~\ref{chapter:automation} details the challenges and solutions to
%our automation engine for verifying C programs.
%In Chapter \ref{chapter:sequential}, we present the concrete Coq
%implementations of the mCertiKOS verified
%kernel using the techniques presented in the previous chapters.
%The framework is further extended in Chapter \ref{chapter:driver}
%to support modular reasoning of device drivers and interrupts.
%A modular framework that can further support shared-memory concurrency
%with fine-grained locking is presented in Chapter \ref{chapter:concurrent}.
%Then, the limitations of various frameworks are discussed in
%Chapter \ref{chapter:limitation}, and we discuss various important
%related works in Chapter \ref{chapter:related}, and finally conclude
%in Chapter \ref{chapter:conclusion}.
%
%\paragraph{My Contributions}
The work described in this thesis is based on joint work with various members
in the CertiKOS project.\footnote{http://flint.cs.yale.edu/certikos/}
The author is one of the two critical contributors for developing the methodology
on performing large scale verification by building stacks of certified abstraction
using two common patterns, presented in Chapter \ref{chapter:framework}. The automation
engines for proving the C source programs (described in Chapter \ref{chapter:automation})
are developed solely by the author, which is particularly suitable for the
layer-based methodology and is the critical component of the framework. 
The author is also one of the two main contributors of the verified kernel (presented
in Chapter \ref{chapter:sequential}), and the
extension to the framework to reason about device drivers and interrupts
(detailed in Chapter \ref{chapter:driver}), and a critical contributor
of the log-based approach on reasoning
concurrent programs (illustrated in Chapter \ref{chapter:concurrent}). 

