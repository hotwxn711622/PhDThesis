To illustrate the effectiveness of our automation engine, in this chapter, we present
how we build, specify, and verify each of the mCertiKOS kernel functions using the tools.
We first present the lowest level machine model, the layer interface MBoot.

\section{Machine Model}
\paragraph{Layer Interface MBoot}

\begin{figure}
\lstinputlisting [language = Coq] {src/mboot_rdata.v}
\caption{The abstract states in the layer interface MBoot}
\label{fig:ref:mboot_rdata}
\end{figure}

The interface MBoot is the lowest level layer interface in mCertiKOS, which is
used to model the behaviors of hardware and the unverified boot loader.
The abstract states of the MBoot interface is shown in Fig.~\ref{fig:ref:mboot_rdata}.

On an x86-based systems, the BIOS reports the physical memory information
through the \textsf{e820} memory map to allow the operating system to figure out
which memory address ranges are usable and which are reserved for use by the BIOS.
The \textsf{e820} table consists of a sequence of triples $(s, l, p)$, indicating
the starting address $s$, the length $l$ of the region from the address $s$, and
the permission $p$ (whether the region is reserved by BIOS or not). This triple
is represented by the abstract type \textsf{MMInfo} in Fig.~\ref{fig:ref:mboot_rdata}.
Since this data is initialized by the boot loader, the
\textsf{MMInfo} in Fig.~\ref{fig:ref:mboot_rdata} also contains the default case
\textsf{MMUndef} to indicate the case when it is not yet initialized by the boot loader.
The whole \textsf{e820} table is represented by \textsf{MM} as a partial map
from integer keys to \textsf{MMInfo}. Since it is a partial map, the number of
\textsf{MMInfo} entries is defined separately as \textsf{MMSize} as shown in
Fig.~\ref{fig:ref:mboot_rdata}.

The MBoot interface also defines a list of primitives to operate on the abstract
memory map. The primitives \textsf{get\_mms}, \textsf{get\_mml}, and \textsf{is\_usable}
receives an integer $i$ as parameter and returns appropriate field in \textsf{MM}
with the key $i$, while the primitive \textsf{get\_size} returns the number of
entries in the table.

There are also three abstract states in MBoot related to the hardware paging.
The abstract state \textsf{CR3} models the hardware \textsf{CR3} register,
which stores the root address of the current page table; the abstract state
\textsf{ti} models the hardware \textsf{CR2} register that stores the fault address
when page fault happens; while the abstract state \textsf{pg} represents
the hardware \textsf{CR0} register indicating whether the paging is turned on or off.
Appropriate primitives are also defined in MBoot to set these states.

The special flags \textsf{ikern} and \textsf{ihost} represent whether the execution
is currently in the kernel and host mode, respectively. They are set to \textsf{true}
when the execution traps into the kernel or host, and are set to \textsf{false} when
the execution returns back to user or the guest.


\begin{figure}
	\lstinputlisting [language=Coq] {src/bootloader.v}
	\caption{The specification of \texttt{boot loader} in Coq}
	\label{fig:bootloader_v}
\end{figure}

The special flag \textsf{init} represents whether the kernel data is fully initialized.
Verification of initialization code has always been a big challenge because the system
data would only satisfy global invariants when they are properly initialized by these code.
In other words, the invariants are not satisfied when these initialization code run but
are established through these initialization process. Existing verification approach
has assumed that all the system data are already properly initialized, thus leaving
all the initialization code unverified \cite{klein2009sel4,klein14}.

To tackle this challenge, we build the initialization stack into a hierarchical structure
instead of the standard flat structure, i.e., each initialization function always first calls
the previous initialization function, then initializes its underlying data. At the bottom layer,
we have the specification of the boot loader, which initializes the \textsf{MM} and \textsf{MMSize}.
Like any other initialization functions, it requires the \textsf{init} to be \textsf{false} at entry, and turns
it to \textsf{true} upon exit. Then all invariants relying on initialized states require that the \textsf{init}
being \textsf{true}, i.e., the the data are properly initialized by corresponding initialization function.
For example, we have following invariant on the \textsf{MM}.

\begin{invariant}[MM valid]
If \textsf{init} is \textsf{true}, for any index $i$ such that $0\le i<MMSize$, we have valid memory mapping
triple of $(s, l, p)$ where $s >= 0$, $l > 0$, and $s + l < Int.max\_unsigned$.
\end{invariant}

Since the MM table and its size comes from BIOS, the invariant is treated as top level
assumption of our entire proof. 

Figure \ref{fig:bootloader_v} presents our Coq specification for the boot loader primitive.
Here, the notation ``\textsf{adt \{attr: val\}}'' indicates a new abstract state where the attribute
\textsf{attr} in \textsf{adt} is replaced by the new value \textsf{val} and otherwise the same
as original \textsf{adt}.
The specification is written as a function which takes the abstract data type \textsf{RData},
and returns a new abstract state or \textsf{None} representing the execution gets stuck.
Our top level specification guarantees that the system execution never gets stuck.
But at this level, the primitive could get stuck when this primitive is misused, e.g., when it is called twice.


\section{Physical Memory Management}

In physical memory management module, we build a physical page allocation map to maintain the
allocation status of physical pages.
The top section in Figure \ref{fig:at_v} shows
the C implementation of the allocation table, where each allocation entry contains the field \textsf{isnorm}
to indicate whether the
physical page is reserved by BIOS, reserved for kernel usage, or free to be used by user programs;
and the field \textsf{allocated} to indicate whether the page is already allocated by the kernel.

\paragraph{Layer Interface MATIntro}
We would like to initialize the allocation information map with the information from the \textsf{MM},
and provide an allocation method to allow the kernel to allocate a physical page.
Before we implement and verify all these functions, following our mantra, we would like to perform
these reasoning completely at the logical level, without worrying about isolation.
As shown in the bottom section of Figure \ref{fig:at_v}, we introduce a new layer interface MATIntro
to abstract the concrete in memory allocation table into a logical map. Here $ZMap.t$ is a partial
map implementation which takes a value type and returns a partial map from integers to the values of given type.

In this layer interface, we provide several getter/setter primitives to operate on this map:
\texttt{at\_get} and \texttt{at\_set} primitives to read and write to the \textsf{allocated} field of \textsf{AT},
and \texttt{is\_norm} and \texttt{set\_norm} for the \textsf{isnorm} field. \texttt{set\_norm} also sets \textsf{allocated}
to \textsf{false} in addition.


\begin{figure}
	\lstinputlisting [language=Coq] {src/at.v}
	\caption{The in-memory and logical representation of allocation table}
	\label{fig:at_v}
\end{figure}

\paragraph{Layer Interface MATInit}

\begin{figure}
	\lstinputlisting [language=C] {src/mem_init.c}
	\caption{The implementation of \texttt{mem\_init} in C}
	\label{fig:mem_init_c}
\end{figure}


\begin{figure}
	\lstinputlisting [language=Coq] {src/mem_init.v}
	\caption{The specification of \texttt{mem\_init} in Coq}
	\label{fig:mem_init_v}
\end{figure}

Next, we would like to initialize this logical allocation table using the information provided
in \textsf{MM}. The concrete C implementation is shown in Figure \ref{fig:mem_init_c}.
Note that as we discussed earlier, first thing it does is to call the lower level initialization
function (boot\_loader in this case) before it performs the actual initialization of its data.
As shown in the figure, it contains two main components. It first computes how much memory
do we have on this machine and sets \textsf{nps} field properly by calling the \texttt{set\_nps} primitive.
Next, it sets proper allocation state for every page based on the information available in \textsf{MM}.
The corresponding Coq specification is shown in Figure \ref{fig:mem_init_v}. 
Comparing to the specification of \texttt{boot\_loader}, the difference is that it also initializes
\textsf{AT} and \textsf{nps} fields in the abstract states to their expected logical values.

The verification of this initialization function is not trivial. But fortunately, our reasoning
is now completely at logical level and there are no in-memory data involved, thus no need
to reason about isolation as they are guaranteed by construction.
And given that this piece of code is verified on top of the layer interface MATIntro,
we can utilize the available invariants on that interface, i.e., the invariants on \textsf{MM}, as given.

The verification is achieved piece by piece. First, we verify the first component where
we compute and sets the maximum number of available physical pages by feeding
following information into our automation engine.

\begin{definition}[Pre-condition] 
\begin{itemize}
\item $\textsf{init} = \textsf{ikern} = \textsf{ihost} = \textsf{true}$,
\item $i=\textsf{nps}=0$, and
\item $\textsf{size}=\textsf{MMSize adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Post-condition] 
\begin{itemize}
\item $\textsf{nps}=\textsf{initial\_nps (MM adt) (MMSize adt)}$, and 
\item $\textsf{adt}'=\textsf{adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Loop Invariant]
\begin{itemize}
\item $0\le i \le \textsf{MMSize adt}$, and
\item $\textsf{nps}=\textsf{initial\_nps (MM adt) i}$.
\end{itemize}
\end{definition}

\begin{definition}[Termination Metric]
$\textsf{MMSize adt}-i$
\end{definition}

\begin{figure}
	\lstinputlisting [language=Coq] {src/nps_loop.v}
	\caption{The main lemma for the loop computing \texttt{nps}}
	\label{fig:nps_loop_v}
\end{figure}

With these information, we can utilize the automation engine to derive the main lemma shown in Figure \ref{fig:nps_loop_v}.
When we verify the main function body, this lemma will be automatically applied by the automation engine to prove
the first loop in the function body.

\begin{figure}
	\lstinputlisting [language=Coq] {src/mm_kern_valid.v}
	\caption{The predicate indicating whether the page is reserved or userable}
	\label{fig:mm_kern_valid_v}
\end{figure}

Next, we verify the main initialization loop. Here, we first verify the inner loop and use the derived lemma to verify the
correctness of the main loop. Following are the list of information we provide to verify the inner loop.
The auxiliary predicate \textsf{MM\_kern\_valid} (shown in Figure \ref{fig:mm_kern_valid_v}) indicates whether
the corresponding physical page is userable or reserved by BIOS.

\begin{definition}[Pre-condition] 
\begin{itemize}
\item $\textsf{init} = \textsf{ikern} = \textsf{ihost} = \textsf{true}$,
\item $j=\textsf{flag}=\textsf{isnorm}=0$,
\item $\textsf{size}=\textsf{MMSize adt}$,
\item $\textsf{nps}=\textsf{nps adt}$, and
\item $\textsf{MEMLOW}\le i < \textsf{MEMHIGH}$.
\end{itemize}
\end{definition}

\begin{definition}[Post-condition] 
\begin{itemize}
\item $\textsf{flag}=\textsf{isnorm}=1$ and $\textsf{MM\_kern\_valid (MM adt) i size}$\\OR\\
$(\textsf{flag}=0$ or $(\textsf{flag}=1$ and $\textsf{isnorm=0}))$\\ and $\textbf{not}~\textsf{MM\_kern\_valid (MM adt) i (MMSize adt)}$
\item $\textsf{adt'}=\textsf{adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Loop Invariant]
\begin{itemize}
\item $0\le j \le \textsf{MMSize adt}$,
\item $\textsf{MEMLOW}\le i < \textsf{MEMHIGH}$,
\item $j=0$ and $\textsf{flag}=0$      OR

$j>0$ and $\textsf{ZMap.get (j-1) (MM adt)} = \textsf{MMValid s l isnorm}$ and

\hspace{10mm}$\textsf{flag}=0$ and ($s > i * PAGESIZE$ or $l + s < (i + 1) * PAGESIZE$)      OR
	
\hspace{10mm}$\textsf{flag}=1$ and $s \le i * PAGESIZE$ and $l + s \geq (i + 1) * PAGESIZE$,

\item for all $j', s', l', isnorm'$, if $0\le j' < j - 1$ and $\textsf{ZMap.get j' (MM adt)} = \textsf{MMValid s' l' isnorm'}$, then
$s' > i * PAGESIZE$ or $l' + s' < (i + 1) * PAGESIZE$.
\end{itemize}
\end{definition}

\begin{definition}[Termination Metric]
$\textsf{MMSize adt}-j$
\end{definition}

We could observe that the inputs for the inner loop is reasonably complicated. It is because
this inner loop is just an auxiliary loop to assist in the main goal of initializing allocation table
in the outer loop, thus may not have a simple meaningful interpretation by itself.
With automation engine, we could derive a correctness lemma for the inner loop similar to the one
we derived for the loop computing \textsf{nps}. This could be used to verify the main outer loop,
as our automation engine can utilize the lemma to discharge the proof goals for the inner while loop.
Unlike inner loop, the inputs for the main loop are reasonably simple.

\begin{definition}[Pre-condition] 
\begin{itemize}
\item $\textsf{init} = \textsf{ikern} = \textsf{ihost} = \textsf{true}$,
\item $i=0$, 
\item $\textsf{size}=\textsf{MMSize adt}$, and
\item $\textsf{nps}=\textsf{nps adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Post-condition] 
$\textsf{adt'}=\textsf{adt \{MM: initial\_AT (MM adt) (MMSize adt)\}}$.
\end{definition}

\begin{definition}[Loop Invariant]
\begin{itemize}
\item $0\le i \le \textsf{nps}$,
\item $\textsf{init}=\textsf{true}$, and
\item $\textsf{AT}=\textsf{initial\_AT (MM adt) i}$.
\end{itemize}
\end{definition}

\begin{definition}[Termination Metric]
$\textsf{nps}-i$
\end{definition}

\begin{figure}
	\lstinputlisting [language=Coq] {src/mem_init_correct.v}
	\caption{The main correctness theorem for \texttt{mem\_init} in Coq}
	\label{fig:mem_init_correct_v}
\end{figure}

With the correctness lemma of the outer loop, we are able to prove the main correctness theorem for
the code \texttt{mem\_init} shown in Figure \ref{fig:mem_init_correct_v}.

In this MATInit layer interface, we also introduce following invariant for abstract \textsf{AT}.

\begin{invariant}[valid AT] If \textsf{init} is \textsf{true}, then
\begin{itemize}
\item every page below \textsf{MEMLOW} or above \textsf{MEMHIGH} is marked as an unallocated kernel-reserved page, and
\item any other page is either reserved by BIOS, or marked as userable.
\end{itemize}
\end{invariant}

Note that the invariant on \textsf{AT} is only introduced at this MATInit layer interface even though the abstract
state \textsf{AT} was already introduced at the previous MATIntro layer. The reason is that at MATIntro layer, 
we have not yet introduced the \textsf{mem\_init} initialization primitive. The initialization primitive on MATIntro layer
is still the \textsf{boot\_loader} primitive. As this primitive turns the \textsf{init} field from \textsf{false} to \textsf{true},
without initializing the \textsf{AT}, this primitive would violate the above invariant if we introduced the invariant at this layer.
On the other hand, as we have proper initialization primitive at the MATInit layer, we now can safely introduce this invariant.
We need to separately prove that the constructed logical initial states in the specification satisfy the invariant, i.e., the \textsf{AT}
is properly initialized. This is done as a separate step, independent from the code verification described above.


\paragraph{Layer Interface MATOp}

\begin{figure}
	\lstinputlisting [language=C] {src/palloc.c}
	\caption{The implementation of \texttt{palloc} in C}
	\label{fig:palloc_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/palloc.v}
	\caption{The specification of \texttt{palloc} in Coq}
	\label{fig:palloc_v}
\end{figure}

\begin{lemma}[Termination] There exists an index $K$ such that either $K=NPS$, or $0<K<NPS$ and the permission of the $K'th$ entry
in AT is normal, and permission of any other entry prior to $K$ is not normal.
\end{lemma}

\begin{lemma} [Unique] Any two indexes satisfying the above conditions are the same indexes.
\end{lemma}

\begin{definition}[Loop Invariant] 
\begin{itemize}
\item $index=NPS$ or $index=K$,
\item $index\le K$, and
\item for every $i$ such that $0<i<index$, the permission of $i'th$ entry in AT is not normal.
\end{itemize}
\end{definition}

With above lemmas, loop invariant, and the decreasing termination metric of $NPS-index$, we can verify
the $palloc$ function reasonably easily with the automation engine.


\section{Virtual Memory Management}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptable.v}
	\caption{The implementation and abstract representation of page table}
	\label{fig:ptable_v}
\end{figure}

\paragraph{Layer Interface MPTIntro}

\begin{figure}
	\lstinputlisting [language=C] {src/ptable_getter_setter.c}
	\caption{The getter and setter functions for page table in C}
	\label{fig:ptable_getter_setter_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptable_getter_setter.v}
	\caption{Selected specifications of page table setters/getters in Coq}
	\label{fig:ptable_getter_setter_v}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptable_getter_setter2.v}
	\caption{Selected specifications of page table setters/getters in Coq}
	\label{fig:ptable_getter_setter2_v}
\end{figure}

...

\paragraph{Layer Interface MPTOp}

\begin{figure}
	\lstinputlisting [language=C] {src/ptableop.c}
	\caption{The functions operates on page table in C}
	\label{fig:ptable_op_c}
\end{figure}

...


\begin{figure}
	\lstinputlisting [language=C] {src/idpde_init.c}
	\caption{The initialization function for IDPDE in C}
	\label{fig:idpde_init_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/idpde_init.v}
	\caption{The specification for IDPDE in Coq}
	\label{fig:idpde_init_v}
\end{figure}

\paragraph{Layer Interface MPTCommon}

\begin{figure}
	\lstinputlisting [language=C] {src/ptablecomm.c}
	\caption{Page allocation and initialization functions in C}
	\label{fig:ptablecomm_c}
\end{figure}

...

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptablecomm.v}
	\caption{Specifications for page allocation and initialization functions in Coq}
	\label{fig:ptablecomm_v}
\end{figure}

\paragraph{Layer Interface MPTKern}

\begin{figure}
	\lstinputlisting [language=C] {src/ptablekern.c}
	\caption{Page allocation and initialization functions in C}
	\label{fig:ptablekern_c}
\end{figure}

...

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptablekern.v}
	\caption{Specifications for page allocation and initialization functions in Coq}
	\label{fig:ptablekern_v}
\end{figure}

\paragraph{Layer Interface MPTInit}

\begin{figure}
	\lstinputlisting [language=C] {src/ptinit.c}
	\caption{Implementation of main page table initialization function in C}
	\label{fig:ptinit_c}
\end{figure}

...

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptinit.v}
	\caption{Specification of main page table initialization function in Coq}
	\label{fig:ptinit_v}
\end{figure}


\begin{invariant}[Page Table Valid]
\begin{itemize}
\item paging is enabled ($\textsf{pg}=\textsf{true}$) only after the page table map is initialized ($\textsf{init}=\textsf{true}$),
\item if $\textsf{init}=\textsf{true}$, the kernel page map (0'th page map in \textsf{ptpool}) is an identity page map with kernel only permission, and
\item if $\textsf{init}=\textsf{true}$, the low memory portion of the rest of page map in \textsf{ptpool} is an identity map with kernel only permissions.
\end{itemize}
\end{invariant}

\paragraph{Layer Interface MPTBit}
...

...



\paragraph{Layer Interface MPTNew}

\begin{figure}
	\lstinputlisting [language=C] {src/ptnew.c}
	\caption{Implementations of \texttt{pt\_resv} and \texttt{pmap\_init} in C}
	\label{fig:ptnew_c}
\end{figure}

...

initializes \textsf{pb} field of abstract states.



\section{Thread Management}

\paragraph{Layer Interface PKContext}

\begin{figure}
	\lstinputlisting [language=C] {src/kctxt.c}
	\caption{Implementation of kernel context in C}
	\label{fig:kctxt_c}
\end{figure}

\textsf{kctx\_switch}

\paragraph{Layer Interface PKContextNew}

\begin{figure}
	\lstinputlisting [language=C] {src/kctxtnew.c}
	\caption{Implementation of \textsf{kctxt\_new} in C}
	\label{fig:kctxtnew_c}
\end{figure}

...

\begin{figure}
	\lstinputlisting [language=Coq] {src/kctxtnew.v}
	\caption{Specification of \textsf{kctxt\_new} in Coq}
	\label{fig:kctxtnew_v}
\end{figure}


\paragraph{Layer Interface PThreadIntro}

\begin{figure}
	\lstinputlisting [language=C] {src/tcb.c}
	\caption{Implementation of thread control block in C}
	\label{fig:tcb_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=C] {src/tdq.c}
	\caption{Implementation of thread queue in C}
	\label{fig:tdq_c}
\end{figure}

\paragraph{Layer Interface PThreadInit}
...

...


\paragraph{Layer Interface PQueueIntro}
...

...

\paragraph{Layer Interface PQueueInit}

\begin{figure}
	\lstinputlisting [language=C] {src/queue_ops.c}
	\caption{Implementation of queue operations in C}
	\label{fig:queue_ops_c}
\end{figure}


\begin{figure}
	\lstinputlisting [language=Coq] {src/abq.v}
	\caption{Specification of abstract queue in Coq}
	\label{fig:abq_v}
\end{figure}

\paragraph{Layer Interface PThreadSched}

\begin{figure}
	\lstinputlisting [language=C] {src/thread.c}
	\caption{Implementation of thread management operations in C}
	\label{fig:thread_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language={[x86masm]Assembler}] {src/thread.s}
	\caption{Implementation of thread scheduler in assembly}
	\label{fig:thread_s}
\end{figure}



\begin{figure}
	\lstinputlisting [language=Coq] {src/thread.v}
	\caption{Specification of thread management operations in Coq}
	\label{fig:thread_v}
\end{figure}


\begin{figure}
	\lstinputlisting [language=Coq] {src/thread_sched.v}
	\caption{Specification of thread scheduler in Coq}
	\label{fig:thread_sched_v}
\end{figure}

\paragraph{Layer Interface PThread}


\begin{figure}
	\lstinputlisting [language={[x86masm]Assembler}] {src/scheduler.s}
	\caption{Implementation of thread yield in assembly}
	\label{fig:scheduler_s}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/scheduler.v}
	\caption{Specification of thread yield in Coq}
	\label{fig:scheduler_v}
\end{figure}

\section{Single-Copy Asynchronous IPC}

\paragraph{Layer Interface PIPCIntro}
...

...

\paragraph{Layer Interface PIPC}
...

...

\section{Process Management}

\paragraph{Layer Interface PUCtxtIntro}
...

...

\paragraph{Layer Interface PProc}
...

...

\section{Intel Virtualization Support}

\paragraph{Layer Interface VEPTIntro}
...

...

\paragraph{Layer Interface VEPTOp}
...

...

\paragraph{Layer Interface VEPTInit}
...

...

\paragraph{Layer Interface VVMCSIntro}
...

...

\paragraph{Layer Interface VVMCSInit}
...

...

\paragraph{Layer Interface VVMXIntro}
...

...

\paragraph{Layer Interface VVMXInit}
...

...

\section{Trap Handling}

\paragraph{Layer Interface TTrapArg}
...

...

\paragraph{Layer Interface TTrap}
...

...

\paragraph{Layer Interface TDispatch}
...

...

\paragraph{Layer Interface TSyscall}
...

...