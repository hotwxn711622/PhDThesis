To illustrate the effectiveness of our automation engine, in this chapter, we present
how we build, specify, and verify each of the mCertiKOS kernel functions using the tools.
We first present the lowest level machine model, the layer interface MBoot.

\section{Machine Model}
\paragraph{Layer Interface MBoot}

\begin{figure}
\lstinputlisting [language = Coq] {src/mboot_rdata.v}
\caption{The abstract states in the layer interface MBoot}
\label{fig:ref:mboot_rdata}
\end{figure}

The interface MBoot is the lowest level layer interface in mCertiKOS, which is
used to model the behaviors of hardware and the unverified boot loader.
The abstract states of the MBoot interface is shown in Fig.~\ref{fig:ref:mboot_rdata}.

On an x86-based systems, the BIOS reports the physical memory information
through the \textsf{e820} memory map to allow the operating system to figure out
which memory address ranges are usable and which are reserved for use by the BIOS.
The \textsf{e820} table consists of a sequence of triples $(s, l, p)$, indicating
the starting address $s$, the length $l$ of the region from the address $s$, and
the permission $p$ (whether the region is reserved by BIOS or not). This triple
is represented by the abstract type \textsf{MMInfo} in Fig.~\ref{fig:ref:mboot_rdata}.
Since this data is initialized by the boot loader, the
\textsf{MMInfo} in Fig.~\ref{fig:ref:mboot_rdata} also contains the default case
\textsf{MMUndef} to indicate the case when it is not yet initialized by the boot loader.
The whole \textsf{e820} table is represented by \textsf{MM} as a partial map
from integer keys to \textsf{MMInfo}. Since it is a partial map, the number of
\textsf{MMInfo} entries is defined separately as \textsf{MMSize} as shown in
Fig.~\ref{fig:ref:mboot_rdata}.

The MBoot interface also defines a list of primitives to operate on the abstract
memory map. The primitives \textsf{get\_mms}, \textsf{get\_mml}, and \textsf{is\_usable}
receives an integer $i$ as parameter and returns appropriate field in \textsf{MM}
with the key $i$, while the primitive \textsf{get\_size} returns the number of
entries in the table.

There are also three abstract states in MBoot related to the hardware paging.
The abstract state \textsf{CR3} models the hardware \textsf{CR3} register,
which stores the root address of the current page table; the abstract state
\textsf{ti} models the hardware \textsf{CR2} register that stores the fault address
when page fault happens; while the abstract state \textsf{pg} represents
the hardware \textsf{CR0} register indicating whether the paging is turned on or off.
Appropriate primitives are also defined in MBoot to set these states.

The special flags \textsf{ikern} and \textsf{ihost} represent whether the execution
is currently in the kernel and host mode, respectively. They are set to \textsf{true}
when the execution traps into the kernel or host, and are set to \textsf{false} when
the execution returns back to user or the guest.


\begin{figure}
	\lstinputlisting [language=Coq] {src/bootloader.v}
	\caption{The specification of \texttt{boot loader} in Coq}
	\label{fig:bootloader_v}
\end{figure}

The special flag \textsf{init} represents whether the kernel data is fully initialized.
Verification of initialization code has always been a big challenge because the system
data would only satisfy global invariants when they are properly initialized by these code.
In other words, the invariants are not satisfied when these initialization code run but
are established through these initialization process. Existing verification approach
has assumed that all the system data are already properly initialized, thus leaving
all the initialization code unverified \cite{klein2009sel4,klein14}.

To tackle this challenge, we build the initialization stack into a hierarchical structure
instead of the standard flat structure, i.e., each initialization function always first calls
the previous initialization function, then initializes its underlying data. At the bottom layer,
we have the specification of the boot loader, which initializes the \textsf{MM} and \textsf{MMSize}.
Like any other initialization functions, it requires the \textsf{init} to be \textsf{false} at entry, and turns
it to \textsf{true} upon exit. Then all invariants relying on initialized states require that the \textsf{init}
being \textsf{true}, i.e., the the data are properly initialized by corresponding initialization function.
For example, we have following invariant on the \textsf{MM}.

\begin{invariant}[MM valid]
If \textsf{init} is \textsf{true}, for any index $i$ such that $0\le i<MMSize$, we have valid memory mapping
triple of $(s, l, p)$ where $s >= 0$, $l > 0$, and $s + l < Int.max\_unsigned$.
\end{invariant}

Since the MM table and its size comes from BIOS, the invariant is treated as top level
assumption of our entire proof. 

Figure \ref{fig:bootloader_v} presents our Coq specification for the boot loader primitive.
Here, the notation ``\textsf{adt \{attr: val\}}'' indicates a new abstract state where the attribute
\textsf{attr} in \textsf{adt} is replaced by the new value \textsf{val} and otherwise the same
as original \textsf{adt}.
The specification is written as a function which takes the abstract data type \textsf{RData},
and returns a new abstract state or \textsf{None} representing the execution gets stuck.
Our top level specification guarantees that the system execution never gets stuck.
But at this level, the primitive could get stuck when this primitive is misused, e.g., when it is called twice.


\section{Physical Memory Management}

In physical memory management module, we build a physical page allocation map to maintain the
allocation status of physical pages.
The top section in Figure \ref{fig:at_v} shows
the C implementation of the allocation table, where each allocation entry contains the field \textsf{isnorm}
to indicate whether the
physical page is reserved by BIOS, reserved for kernel usage, or free to be used by user programs;
and the field \textsf{allocated} to indicate whether the page is already allocated by the kernel.

\paragraph{Layer Interface MATIntro}
We would like to initialize the allocation information map with the information from the \textsf{MM},
and provide an allocation method to allow the kernel to allocate a physical page.
Before we implement and verify all these functions, following our mantra, we would like to perform
these reasoning completely at the logical level, without worrying about isolation.
As shown in the bottom section of Figure \ref{fig:at_v}, we introduce a new layer interface MATIntro
to abstract the concrete in memory allocation table into a logical map. Here $ZMap.t$ is a partial
map implementation which takes a value type and returns a partial map from integers to the values of given type.

In this layer interface, we provide several getter/setter primitives to operate on this map:
\texttt{at\_get} and \texttt{at\_set} primitives to read and write to the \textsf{allocated} field of \textsf{AT},
and \texttt{is\_norm} and \texttt{set\_norm} for the \textsf{isnorm} field. \texttt{set\_norm} also sets \textsf{allocated}
to \textsf{false} in addition.


\begin{figure}
	\lstinputlisting [language=Coq] {src/at.v}
	\caption{The in-memory and logical representation of allocation table}
	\label{fig:at_v}
\end{figure}

\paragraph{Layer Interface MATInit}

\begin{figure}
	\lstinputlisting [language=C] {src/mem_init.c}
	\caption{The implementation of \texttt{mem\_init} in C}
	\label{fig:mem_init_c}
\end{figure}


\begin{figure}
	\lstinputlisting [language=Coq] {src/mem_init.v}
	\caption{The specification of \texttt{mem\_init} in Coq}
	\label{fig:mem_init_v}
\end{figure}

Next, we would like to initialize this logical allocation table using the information provided
in \textsf{MM}. The concrete C implementation is shown in Figure \ref{fig:mem_init_c}.
Note that as we discussed earlier, first thing it does is to call the lower level initialization
function (boot\_loader in this case) before it performs the actual initialization of its data.
As shown in the figure, it contains two main components. It first computes how much memory
do we have on this machine and sets \textsf{nps} field properly by calling the \texttt{set\_nps} primitive.
Next, it sets proper allocation state for every page based on the information available in \textsf{MM}.
The corresponding Coq specification is shown in Figure \ref{fig:mem_init_v}. 
Comparing to the specification of \texttt{boot\_loader}, the difference is that it also initializes
\textsf{AT} and \textsf{nps} fields in the abstract states to their expected logical values.

The verification of this initialization function is not trivial. But fortunately, our reasoning
is now completely at logical level and there are no in-memory data involved, thus no need
to reason about isolation as they are guaranteed by construction.
And given that this piece of code is verified on top of the layer interface MATIntro,
we can utilize the available invariants on that interface, i.e., the invariants on \textsf{MM}, as given.

The verification is achieved piece by piece. First, we verify the first component where
we compute and set the maximum number of available physical pages by feeding
following information into our automation engine.

\begin{definition}[Pre-condition] 
\begin{itemize}
\item $\textsf{init} = \textsf{ikern} = \textsf{ihost} = \textsf{true}$,
\item $i=\textsf{nps}=0$, and
\item $\textsf{size}=\textsf{MMSize adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Post-condition] 
\begin{itemize}
\item $\textsf{nps}=\textsf{initial\_nps (MM adt) (MMSize adt)}$, and 
\item $\textsf{adt}'=\textsf{adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Loop Invariant]
\begin{itemize}
\item $0\le i \le \textsf{MMSize adt}$, and
\item $\textsf{nps}=\textsf{initial\_nps (MM adt) i}$.
\end{itemize}
\end{definition}

\begin{definition}[Termination Metric]
$\textsf{MMSize adt}-i$
\end{definition}

\begin{figure}
	\lstinputlisting [language=Coq] {src/nps_loop.v}
	\caption{The main lemma for the loop computing \texttt{nps}}
	\label{fig:nps_loop_v}
\end{figure}

With these information, we can utilize the automation engine to derive the main lemma shown in Figure \ref{fig:nps_loop_v}.
When we verify the main function body, this lemma will be automatically applied by the automation engine to prove
the first loop in the function body.

\begin{figure}
	\lstinputlisting [language=Coq] {src/mm_kern_valid.v}
	\caption{The predicate indicating whether the page is reserved or userable}
	\label{fig:mm_kern_valid_v}
\end{figure}

Next, we verify the main initialization loop. Here, we first verify the inner loop and use the derived lemma to verify the
correctness of the main loop. Following are the list of information we provide to verify the inner loop.
The auxiliary predicate \textsf{MM\_kern\_valid} (shown in Figure \ref{fig:mm_kern_valid_v}) indicates whether
the corresponding physical page is userable or reserved by BIOS.

\begin{definition}[Pre-condition] 
\begin{itemize}
\item $\textsf{init} = \textsf{ikern} = \textsf{ihost} = \textsf{true}$,
\item $j=\textsf{flag}=\textsf{isnorm}=0$,
\item $\textsf{size}=\textsf{MMSize adt}$,
\item $\textsf{nps}=\textsf{nps adt}$, and
\item $\textsf{MEMLOW}\le i < \textsf{MEMHIGH}$.
\end{itemize}
\end{definition}

\begin{definition}[Post-condition] 
\begin{itemize}
\item $\textsf{flag}=\textsf{isnorm}=1$ and $\textsf{MM\_kern\_valid (MM adt) i size}$\\OR\\
$(\textsf{flag}=0$ or $(\textsf{flag}=1$ and $\textsf{isnorm=0}))$\\ and $\textbf{not}~\textsf{MM\_kern\_valid (MM adt) i (MMSize adt)}$
\item $\textsf{adt'}=\textsf{adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Loop Invariant]
\begin{itemize}
\item $0\le j \le \textsf{MMSize adt}$,
\item $\textsf{MEMLOW}\le i < \textsf{MEMHIGH}$,
\item $j=0$ and $\textsf{flag}=0$      OR

$j>0$ and $\textsf{ZMap.get (j-1) (MM adt)} = \textsf{MMValid s l isnorm}$ and

\hspace{10mm}$\textsf{flag}=0$ and ($s > i * PAGESIZE$ or $l + s < (i + 1) * PAGESIZE$)      OR
	
\hspace{10mm}$\textsf{flag}=1$ and $s \le i * PAGESIZE$ and $l + s \geq (i + 1) * PAGESIZE$,

\item for all $j', s', l', isnorm'$, if $0\le j' < j - 1$ and $\textsf{ZMap.get j' (MM adt)} = \textsf{MMValid s' l' isnorm'}$, then
$s' > i * PAGESIZE$ or $l' + s' < (i + 1) * PAGESIZE$.
\end{itemize}
\end{definition}

\begin{definition}[Termination Metric]
$\textsf{MMSize adt}-j$
\end{definition}

We could observe that the inputs for the inner loop is reasonably complicated. It is because
this inner loop is just an auxiliary loop to assist in the main goal of initializing allocation table
in the outer loop, thus may not have a simple meaningful interpretation by itself.
With automation engine, we could derive a correctness lemma for the inner loop similar to the one
we derived for the loop computing \textsf{nps}. This could be used to verify the main outer loop,
as our automation engine can utilize the lemma to discharge the proof goals for the inner while loop.
Unlike inner loop, the inputs for the main loop are reasonably simple.

\begin{definition}[Pre-condition] 
\begin{itemize}
\item $\textsf{init} = \textsf{ikern} = \textsf{ihost} = \textsf{true}$,
\item $i=0$, 
\item $\textsf{size}=\textsf{MMSize adt}$, and
\item $\textsf{nps}=\textsf{nps adt}$.
\end{itemize}
\end{definition}

\begin{definition}[Post-condition] 
$\textsf{adt'}=\textsf{adt \{MM: initial\_AT (MM adt) (MMSize adt)\}}$.
\end{definition}

\begin{definition}[Loop Invariant]
\begin{itemize}
\item $0\le i \le \textsf{nps}$,
\item $\textsf{init}=\textsf{true}$, and
\item $\textsf{AT}=\textsf{initial\_AT (MM adt) i}$.
\end{itemize}
\end{definition}

\begin{definition}[Termination Metric]
$\textsf{nps}-i$
\end{definition}

\begin{figure}
	\lstinputlisting [language=Coq] {src/mem_init_correct.v}
	\caption{The main correctness theorem for \texttt{mem\_init} in Coq}
	\label{fig:mem_init_correct_v}
\end{figure}

With the correctness lemma of the outer loop, we are able to prove the main correctness theorem for
the code \texttt{mem\_init} shown in Figure \ref{fig:mem_init_correct_v}.

In this MATInit layer interface, we also introduce following invariant for abstract \textsf{AT}.

\begin{invariant}[valid AT] If \textsf{init} is \textsf{true}, then
\begin{itemize}
\item every page below \textsf{MEMLOW} or above \textsf{MEMHIGH} is marked as an unallocated kernel-reserved page, and
\item any other page is either reserved by BIOS, or marked as userable.
\end{itemize}
\end{invariant}

Note that the invariant on \textsf{AT} is only introduced at this MATInit layer interface even though the abstract
state \textsf{AT} was already introduced at the previous MATIntro layer. The reason is that at MATIntro layer, 
we have not yet introduced the \textsf{mem\_init} initialization primitive. The initialization primitive on MATIntro layer
is still the \textsf{boot\_loader} primitive. As this primitive turns the \textsf{init} field from \textsf{false} to \textsf{true},
without initializing the \textsf{AT}, this primitive would violate the above invariant if we introduced the invariant at this layer.
On the other hand, as we have proper initialization primitive at the MATInit layer, we now can safely introduce this invariant.
We need to separately prove that the constructed logical initial states in the specification satisfy the invariant, i.e., the \textsf{AT}
is properly initialized. This is done as a separate step, independent from the code verification described above.


\paragraph{Layer Interface MATOp}

In this layer, we introduce the main physical page allocation function \textsf{palloc}.
As shown in Figure \ref{fig:palloc_c}, the function seeks for the first unused physical page,
marks it as used, and returns the index of the page found.
The specification shown in Figure \ref{fig:palloc_v} is similar, except it manipulates
the abstract state \textsf{AT} instead of the concrete in memory data.

\begin{figure}
	\lstinputlisting [language=C] {src/palloc.c}
	\caption{The implementation of \texttt{palloc} in C}
	\label{fig:palloc_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/palloc.v}
	\caption{The specification of \texttt{palloc} in Coq}
	\label{fig:palloc_v}
\end{figure}

The verification of this function is reasonably straightforward. We first verify that
the while loop indeed terminates with the index to the first unused physical page when such page is available.
To prove that, we need following two lemmas.

\begin{lemma}[Termination] There exists an index $K$ such that either $K=NPS$, or $0<K<NPS$ and the permission of the $K'th$ entry
in AT is normal, and permission of any other entry prior to $K$ is not normal.
\end{lemma}

\begin{lemma} [Unique] Any two indexes satisfying the above conditions are the same indexes.
\end{lemma}

With above lemmas, we can feed following loop invariant, and the decreasing termination metric of $NPS-index$ to 
the automation engine to verify the while loop, and further the entire $palloc$ function reasonably easily.

\begin{definition}[Loop Invariant] 
\begin{itemize}
\item $index=NPS$ or $index=K$,
\item $index\le K$, and
\item for every $i$ such that $0<i<index$, the permission of $i'th$ entry in AT is not normal.
\end{itemize}
\end{definition}



\section{Virtual Memory Management}

On top of the physical memory management layers, we introduce the
virtual memory management layers.
We implement the two level page table structure, where the second level
page table entries are dynamically allocated when the user accesses an unallocated virtual memory.
Page table 0 is reserved for kernel page table and the whole page table is set to an identity map.
For every process's page table, we map the low memory as an identity map with kernel only permission,
so that when each process traps into the kernel, we no longer need to switch to the kernel page table, 
but can still access kernel data natively via memory access.

The top section of Figure \ref{fig:ptable_v} shows the implementation of the two level page table.
The \textsf{PTPool} is a list of page directory entries for each of the process and the kernel (page number 0).
Since we map many portion of various page tables to identity maps, we statically allocate one page table entry
structure (\textsf{IDPMap} in the Figure), and simply map its address to every page directory entry where
we would like to set to the identity mapping.
The bottom section of the Figure shows the abstract logical representation of the page table structure.
As shown in the figure, a page table is a partial map from page directory index to page directory entry.
Each page directory entry is either mapped to proper page table entry (\textsf{PDEValid}),
mapped to an identity map (\textsf{PDEID}), remaining unallocated (\textsf{PDEUnPresent}), or uninitialized or invalid (\textsf{PDEUndef}).
A page table entry is either mapped to a valid address with proper permission (\textsf{PTEValid}), remaining unmapped (\textsf{PTEUnPresent}),
or uninitialized or invalid (\textsf{PTEUndef}).

In the following subsections, we introduce each individual layer interfaces for verification of various
virtual memory management code modules.

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptable.v}
	\caption{The implementation and abstract representation of page table}
	\label{fig:ptable_v}
\end{figure}

\paragraph{Layer Interface MPTIntro}

\begin{figure}
	\lstinputlisting [language=C] {src/ptable_getter_setter.c}
	\caption{The getter and setter functions for page table in C}
	\label{fig:ptable_getter_setter_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptable_getter_setter.v}
	\caption{Selected specifications of page table setters/getters in Coq}
	\label{fig:ptable_getter_setter_v}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptable_getter_setter2.v}
	\caption{Selected specifications of page table setters/getters in Coq}
	\label{fig:ptable_getter_setter2_v}
\end{figure}

To follow our mantra, we first perform data abstraction to abstract the in-memory
page table structure into the logical page table map shown in Figure \ref{fig:ptable_v},
and introduce the getter and setter methods.
Implementations of those functions are shown in Figure \ref{fig:ptable_getter_setter_c}.
Note that in CompCert memory model, integers and pointers are two different incompatible
types and one cannot be casted to the other. Thus, in order to add the permission bits
to the end of the page directory entry address, we have to rely on the pointer arithmetic.
Since the permissions are not always the multiple of four, we implement the \textsf{PTPool}
as arrays of \textsf{char} so that we can add arbitrary permissions to the addresses via
pointer arithmetic of \textsf{char *}.

Figure \ref{fig:ptable_getter_setter_v} and \ref{fig:ptable_getter_setter2_v} shows the
specifications of the corresponding functions that manipulating the abstract page tables mappings.
Note that the specification also validates that the arguments passed in are within the proper range
and gets stuck if not, even though in the implementation, we do not perform this check.
This can make sure that we always pass in valid arguments, without actually hindering the performance
by doing the check at run time.

\paragraph{Layer Interface MPTOp}

On top of the MPTIntro, we introduce a new layer interface and implement
slightly higher level functions reading and writing the page table mappings that directly
take the virtual address as argument (see Figure \ref{fig:ptable_op_c}).

In addition, we also introduce the function to initialize the \textsf{IDPMap} as a identity map,
with the implementation shown in Figure \ref{fig:idpde_init_c}, and the specification shown
in Figure \ref{fig:idpde_init_v}.

Despite the nested while loop, the verification of the \textsf{idpde\_init} is reasonably
intuitive and can be performed similarly to other functions with loops as before.
As in this layer, our initialization method also initializes the \textsf{IDPMap}, we can
introduce a layer invariant on \textsf{IDPMap}, stating it is an identity map.

\begin{figure}
	\lstinputlisting [language=C] {src/ptableop.c}
	\caption{The functions operates on page table in C}
	\label{fig:ptable_op_c}
\end{figure}


\begin{figure}
	\lstinputlisting [language=C] {src/idpde_init.c}
	\caption{The initialization function for IDPDE in C}
	\label{fig:idpde_init_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/idpde_init.v}
	\caption{The specification for IDPDE in Coq}
	\label{fig:idpde_init_v}
\end{figure}

\paragraph{Layer Interface MPTCommon}

In this layer interface, we further introduce a higher level functions to allocate and free the first level page directory entries.
In addition, the initialization function of page tables is added to initialize the low memory section as identity map with kernel-only
permission, and mark the rest of sections as unallocated.
Their implementations are shown in Figure \ref{fig:ptablecomm_c}, and specifications are presented in Figure \ref{fig:ptablecomm_v}.

\begin{figure}
	\lstinputlisting [language=C] {src/ptablecomm.c}
	\caption{Page allocation and initialization functions in C}
	\label{fig:ptablecomm_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptablecomm.v}
	\caption{Specifications for page allocation and initialization functions in Coq}
	\label{fig:ptablecomm_v}
\end{figure}

The verification of these method are similar to the ones presented before containing the loops, and are not detailed here.

\paragraph{Layer Interface MPTKern}

Next, we introduce the two primitives \textsf{pt\_insert} and \textsf{pt\_rmv} that links and unlinks the provided virtual and physical
pages, and introduce a new initialization function that further initializes the high memory section of the page table 0 (kernel page table)
to the identity map, so that the whole page table 0 is the identity map. Their implementations are shown in Figure
\ref{fig:ptablekern_c}, and part of specifications can be found in Figure \ref{fig:ptablekern_v}.

\begin{figure}
	\lstinputlisting [language=C] {src/ptablekern.c}
	\caption{Page allocation and initialization functions in C}
	\label{fig:ptablekern_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptablekern.v}
	\caption{Specifications for page allocation and initialization functions in Coq}
	\label{fig:ptablekern_v}
\end{figure}

\paragraph{Layer Interface MPTInit}

Finally, in this layer interface MPTInit, we introduce the main initialization function of the page table
\textsf{pt\_init}, where it first calls \textsf{pt\_init\_kern} in interface MPTKern to initialize the 
page table structure properly, sets the current page table (CR3) to page table 0, then enable
the paging (see Figure \ref{fig:ptinit_c}).
The specification of function \textsf{pt\_init} is shown in Figure \ref{fig:ptinit_v}.

\begin{figure}
	\lstinputlisting [language=C] {src/ptinit.c}
	\caption{Implementation of main page table initialization function in C}
	\label{fig:ptinit_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/ptinit.v}
	\caption{Specification of main page table initialization function in Coq}
	\label{fig:ptinit_v}
\end{figure}

At this point, we now introduce the main invariants for the page table structure as follows.

\begin{invariant}[Page Table Valid]
\begin{itemize}
\item paging is enabled ($\textsf{pg}=\textsf{true}$) only after the page table map is initialized ($\textsf{init}=\textsf{true}$),
\item if $\textsf{init}=\textsf{true}$, the kernel page map (0'th page map in \textsf{ptpool}) is an identity page map with kernel only permission, and
\item if $\textsf{init}=\textsf{true}$, the low memory portion of the rest of page map in \textsf{ptpool} is an identity map with kernel only permissions.
\end{itemize}
\end{invariant}

\paragraph{Layer Interface MPTBit}

Now that we have the code to initialize and manipulate the page table structure, in this layer interface,
we introduce a bit map of size \textsf{NUM\_PROC}, to record whether each process is already spawn or
free. We introduce a getter function \textsf{is\_used}, and a setter \textsf{set\_bit} in this layer as well to
read and write to the new bitmap.


\paragraph{Layer Interface MPTNew}

We introduce a couple of new functions in the layer interface MPTNew.
First, we introduce a new initialization function \textsf{pmap\_init} which in addition initializes the new bitmap introduced in MPTBit.
As shown in Figure \ref{fig:ptnew_c}, only the 0'th bit is marked as used (reserved for the kernel process).
Second, we introduce the function \textsf{pt\_resv} to allocate a new page and maps that page to the required virtual address.
This function is later called by the page fault handler when the user tries to access a valid virtual address that is not yet allocated,
and \textsf{pt\_resv} dynamically allocates and maps a new physical page for the user at the corresponding virtual address.
Last, we also introduce a new primitive \textsf{pt\_new} that returns the first unused process ID based on the bitmap.

\begin{figure}
	\lstinputlisting [language=C] {src/ptnew.c}
	\caption{Implementations of \texttt{pt\_resv} and \texttt{pmap\_init} in C}
	\label{fig:ptnew_c}
\end{figure}


\section{Thread Management}

\paragraph{Layer Interface PKContext}

In this layer interface, we introduce the kernel context for each kernel thread (shown in Figure \ref{fig:kctxt_c}),
together with the two setter functions to set the \textsf{SP} and \textsf{RA} field of the context.
In addition, we also introduce the \textsf{kctx\_switch} function implemented in assembly for switching two kernel contexts.

\begin{figure}
	\lstinputlisting [language=C] {src/kctxt.c}
	\caption{Implementation of kernel context in C}
	\label{fig:kctxt_c}
\end{figure}


\paragraph{Layer Interface PKContextNew}

Next, the layer interface PKContextNew introduces one new primitive \textsf{kctxt\_new}, which finds the next
available process, and sets the stack pointer and the function entry pointer properly in its kernel context.
As shown in Figure \ref{fig:kctxtnew_c}, we statically allocate one page for each potential process for its kernel
stack, and sets the stack pointer of each new process to be the top of corresponding stack page.
The $-4$ subtracted from the stack top is the typical safety enhancement to make sure we are less likely to
exceed the stack boundary when we manipulate the stack, and it is not really necessary here as our kernel
is formally verified for absence of stack overflow.
The abstract specification of \textsf{kctxt\_new} is shown in Figure \ref{fig:kctxtnew_v}.

\begin{figure}
	\lstinputlisting [language=C] {src/kctxtnew.c}
	\caption{Implementation of \textsf{kctxt\_new} in C}
	\label{fig:kctxtnew_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/kctxtnew.v}
	\caption{Specification of \textsf{kctxt\_new} in Coq}
	\label{fig:kctxtnew_v}
\end{figure}


\paragraph{Layer Interface PThreadIntro}

The layer interface PThreadIntro implements and abstracts the thread control block (TCB).
As shown in Figure \ref{fig:tcb_c}, we statically allocate a pool of TCBs for the number of
processes. Each TCB contains the state of the corresponding thread, and the indexes of
the previous and next TCBs in the TCB pool. This way, we can link TCBs in both directions
to form bi-directional thread queues. As shown in the figure, PThreadIntro also implements
a list of getter and setter primitives to manipulate the logical TCB pool.

\begin{figure}
	\lstinputlisting [language=C] {src/tcb.c}
	\caption{Implementation of thread control block in C}
	\label{fig:tcb_c}
\end{figure}

\paragraph{Layer Interface PThreadInit}

In this layer interface, we introduce the new initialization function \textsf{thread\_init} to initialize
the logical TCB pool. As shown in Figure \ref{fig:tcb_c}, the thread state in every TCB is marked
dead, and the previous and next TCB indexes are set to the invalid index.

\paragraph{Layer Interface PQueueIntro}

PQueueIntro introduces the abstract thread queues. As shown in Figure \ref{fig:tdq_c}, a thread queue
is represented simply as pair of indexes in the static TCB pool representing the head and tail TCBs.
Here, the \textsf{num\_chan} represents the number of IPC channels we support in the kernel.
We allocate one thread sleeping queue per IPC channel for the threads waiting on that channel,
and one additional thread queue for the ready queue used by the thread scheduler.
We also introduce a list of getter and setter functions to manipulate the head and tail of the abstract
queue as shown in Figure \ref{fig:tdq_c}.

\begin{figure}
	\lstinputlisting [language=C] {src/tdq.c}
	\caption{Implementation of thread queue in C}
	\label{fig:tdq_c}
\end{figure}

\paragraph{Layer Interface PQueueInit}

In layer interface PQueueInit, we introduce the main \textsf{enqueue} and \textsf{dequeue} operators
to push and pop TCB into and from the queue (see Figure \ref{fig:queue_ops_c}), and also a new
initialization primitive \textsf{tdqueue\_init} to initialize each queue as empty (see Figure \ref{fig:tdq_c}).

\begin{figure}
	\lstinputlisting [language=C] {src/queue_ops.c}
	\caption{Implementation of queue operations in C}
	\label{fig:queue_ops_c}
\end{figure}

\paragraph{Layer Interface PAbQueue}

The verification of the thread queue is achieved in a very similar way to
verification of console circular buffer illustrated as running example in Chapter \ref{chapter:framework}.
Figure \ref{fig:abq_v} shows the ultimate abstract representation of the abstract TCB and the thread queue.
As shown in the figure, an abstract TCB is either undefined (uninitialized) or a valid TCB with a thread state
and an index to the list of abstract queues (with value $-1$ indicating it is not in any of the queues).
A valid abstract queue is simply a list of indexes of TCBs in the abstract TCB pool.
Similar to the techniques presented in Chapter \ref{chapter:framework}, before this layer interface
PAbQueue, we represent the abstract TCB and the queue in a way very similar to their implementations in C, i.e.,
using the list and indexes, and all the getter, setter, enqueue, and dequeue operations are all specified using
this intermediate abstract representations. The benefit is that this makes the verification of the TCB and queue
manipulating functions easier as their specifications and implementations are relatively close.
Once this is achieved, in this layer interface PAbQueue, we turn the abstract TCB and queue representation
into the ultimate logical one shown in Figure \ref{fig:abq_v}, and turn all the specifications to use this representation.
Then we verify that the layer interface PQueueInit and PAbQueue are contextual equivalent, without involving any
reasoning on the actual code, completely at logical level.
The specifications of \textsf{enqueue} and \textsf{dequeue} using the more abstract representations are
shown in Figure \ref{fig:abq_v}. Here, the specifications are much simpler and readerable comparing to their
specifications in the layer interface PQueueInit, as the queue is presented as a simple list with less number of
indirection.

\begin{figure}
	\lstinputlisting [language=Coq] {src/abq.v}
	\caption{Specification of abstract queue in Coq}
	\label{fig:abq_v}
\end{figure}

In this layer, we also introduce following set of layer invariants. Note that we do not need to include unnecessary
invariants in PQueueInit because they would have been much more complex using the more concrete
representations and we would not be able to prove the contextual refinement if PQueueInit does not satisfy
the invariants corresponding to the ones we added in PAbQueue layer interface here.

\begin{invariant}[AbTCB Valid]
If $\textsf{init}=\textsf{true}$, then every TCB is valid with $-1\le b \le \textsf{num\_chan}$.
\end{invariant}

\begin{invariant}[AbQ Valid]
Every index $i$ in any queue has range $0\le i < \textsf{num\_proc}$.
\end{invariant}

\begin{invariant}[Dead TCB Not In Queue]
The index of any unallocated process is not in any queue, i.e., $b=-1$ in corresponding TCB.
\end{invariant}

\begin{invariant}[At Most One Queue]
For every TCB with index $i$, if $b\neq -1$, then there is exactly one $i$ in the $b'th$ abstract queue.
\end{invariant}

\begin{invariant}[Consistent In Queue]
For every queue, and every index $i$ in the queue, $b=i$ in the $i'th$ TCB.
\end{invariant}

\paragraph{Layer Interface PThreadSched}

In PThreadSched, we introduce part of scheduler primitives and one initialization primitive shown in
Figure \ref{fig:thread_c}. The function \textsf{thread\_spawn} first allocates a new kernel context,
sets its state to \textsf{READY}, puts it to the scheduler ready queue \footnote{Recall that
the last queue with index \textsf{num\_chan} is for the ready queue, while the rest is for the
IPC sleeping queues}, and returns the new process ID.
The function \textsf{thread\_wakeup} pops the index of the first sleeping process from the corresponding
sleeping queue indexed by the \textsf{channel\_index} if the queue is not empty, sets its state to be \textsf{READY},
and inserts it to the scheduler's ready queue so that it can be scheduled.
The new initialization primitive calls the previous initialization primitive \textsf{tdqueue\_init}, marks
the current thread ID to be 0 (kernel), and marks the kernel thread as running.
The specifications of \textsf{thread\_spawn} and \textsf{thread\_wakeup} primitives can be found
in Figure \ref{fig:thread_v}. The verification is trivial as they are mostly straight line code.

\begin{figure}
	\lstinputlisting [language=C] {src/thread.c}
	\caption{Implementation of thread management operations in C}
	\label{fig:thread_c}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/thread.v}
	\caption{Specification of thread management operations in Coq}
	\label{fig:thread_v}
\end{figure}

In addition to the primitives we introduced above, PThreadSched also includes another
scheduler related primitive \textsf{thread\_sched}.
As shown in Figure \ref{fig:thread_s}, \textsf{thread\_sched} is implemented in
assembly instead of C, because it calls the function \textsf{kctxt\_switch} which
is implemented in assembly. The implementation shown in Figure \ref{fig:thread_s}
is in the standard assembly source format that we present for the ease of readability,
while the actual source code in Coq is shown in Figure \ref{fig:thread_sched_v}.
Figure \ref{fig:thread_sched_v} also shows is specification.
From the assembly source code, we can find that the code is merely a straight line
code with a list of function calls with proper arguments prepared. This is done in purpose to
encapsulate all the complex loops and branching logic within verified functions implemented in C,
and make the actual function implemented in assembly simple. Thus, even though we do not
have as mature automation support as we have in verifying C code, the verification of \textsf{thread\_sched}
assembly implementation against its specification in Figure \ref{fig:thread_sched_v} is accessible.

\begin{figure}
	\lstinputlisting [language={[x86masm]Assembler}] {src/thread.s}
	\caption{Implementation of thread scheduler in assembly}
	\label{fig:thread_s}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/thread_sched.v}
	\caption{Specification of thread scheduler in Coq}
	\label{fig:thread_sched_v}
\end{figure}

\paragraph{Layer Interface PThread}

In this layer interface, we introduce the two main scheduler functions \textsf{thread\_yield} and
\textsf{thread\_sleep}. They are both implemented in assembly as they both call \textsf{thread\_sched}.
As an example, the implementation of \textsf{thread\_yield} is shown in Figure \ref{fig:scheduler_s}, and
its specification is shown in Figure \ref{fig:scheduler_v}.

\begin{figure}
	\lstinputlisting [language={[x86masm]Assembler}] {src/scheduler.s}
	\caption{Implementation of thread yield in assembly}
	\label{fig:scheduler_s}
\end{figure}

\begin{figure}
	\lstinputlisting [language=Coq] {src/scheduler.v}
	\caption{Specification of thread yield in Coq}
	\label{fig:scheduler_v}
\end{figure}

At PThread layer, we have full set of thread scheduling primitives, and we no longer expose the low
level primitives manipulating thread queues directly. Thus, we now introduce a stronger invariant
to our abstract TCB as shown below.

\begin{invariant}[AbTCB Valid Strong]
For every valid TCB (\textsf{AbTCBValid s b}), $b=-1$ if $s=\textsf{RUN}$ or $s=\textsf{DEAD}$,
$0\le b < \textsf{num\_chan}$ when $s=\textsf{SLEEP}$, and $b=\textsf{num\_chan}$ when $s=\textsf{READY}$.
\end{invariant}


\section{Single-Copy Asynchronous IPC}

We have implemented two additional layer interface PIPCIntro and PIPC on top of the PThread layer for a single-copy
synchronous inter-process communication (IPC) protocol. 
Every IPC message contains the sender's virtual address of the sender message buffer, and the number of bytes sent.
The layer interface PIPCIntro abstracts the IPC message into abstract buffer and introduces the getter and setter primitives.
The layer PIPC introduces the main \textsf{sync\_sendto\_chan} and \textsf{sync\_receive\_chan} primitives to send and receive
messages between processes synchronously. 

\section{Process Management}

\paragraph{Layer Interface PUCtxtIntro}

In PUCtxtIntro, we introduce the user context that contains the list of user registers that we save
and restore when user traps into the kernel or jumps back to the user space, in addition to
the primitives to actually save and restore the user registers. Note that we only save and restore the second
half in software, as the first half is automatically saved and restored by the hardware.

\paragraph{Layer Interface PProc}

In this layer interface, we introduce the primitive \textsf{proc\_create} that spawns a new process,
where it spawns the managing kernel thread via \textsf{thread\_spawn}, loads ELF, and sets proper
user context using the setter primitives from the PUCtxtIntro layer.

\section{Intel Virtualization Support}

On top of PProc, we implement the hardware-assisted virtualization technology Intel VT-x.

\paragraph{Layer Interface VEPTIntro}

In VEPTIntro, we introduce the four level Extended Page Table (EPT). The concrete implementation in C
and the corresponding abstract logical representation is shown in Figure \ref{fig:ept_v}.
This is similar to the two level in-kernel page table structure except it has two additional levels.
The corresponding getter and setter functions introduced are shown in Figure \ref{fig:ept_c}.

\begin{figure}
	\lstinputlisting [language=Coq] {src/ept.v}
	\caption{Concrete and abstract EPT}
	\label{fig:ept_v}
\end{figure}

\begin{figure}
	\lstinputlisting [language=C] {src/ept.c}
	\caption{Implementation of getter and setter functions of EPT in C}
	\label{fig:ept_c}
\end{figure}

\paragraph{Layer Interface VEPTInit}


\begin{figure}
	\lstinputlisting [language=C] {src/eptop.c}
	\caption{Implementation of EPT operations in C}
	\label{fig:eptop_c}
\end{figure}

\paragraph{Layer Interface VEPTOp}

\begin{figure}
	\lstinputlisting [language=C] {src/eptinit.c}
	\caption{Implementation of EPT operations in C}
	\label{fig:eptinit_c}
\end{figure}

\paragraph{Layer Interface VVMCSIntro}
...

...

\paragraph{Layer Interface VVMCSInit}
...

...

\paragraph{Layer Interface VVMXIntro}
...

...

\paragraph{Layer Interface VVMXInit}
...

...

\section{Trap Handling}

\paragraph{Layer Interface TTrapArg}
...

...

\paragraph{Layer Interface TTrap}
...

...

\paragraph{Layer Interface TDispatch}
...

...

\paragraph{Layer Interface TSyscall}
...

...